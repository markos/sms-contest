<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>thread_pool.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>thread_pool.cpp</h1><a href="thread__pool_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">// $Id: thread_pool.cpp,v 2.3 2003/08/25 08:50:45 markos Exp $</span>
00002 
00003 <span class="preprocessor">#include "<a class="code" href="thread__pool_8h.html">thread_pool.h</a>"</span>
00004 
00005 <span class="comment">/* We need this header so that we can invoke handle_input() on the</span>
00006 <span class="comment">   objects we dequeue.  */</span>
00007 <span class="preprocessor">#include "ace/Event_Handler.h"</span>
00008 
<a name="l00010"></a><a class="code" href="classThread__Pool.html#Thread__Poola0">00010</a> <a class="code" href="classThread__Pool.html#Thread__Poola0">Thread_Pool::Thread_Pool</a> (<span class="keywordtype">void</span>)
00011   : active_threads_ (0)
00012 {
00013 }
00014 
00015 <span class="comment">/* Our start() method is a thin disguise around the ACE_Task&lt;&gt;</span>
00016 <span class="comment">   activate() method.  By hiding activate() in this way, the users of</span>
00017 <span class="comment">   Thread_Pool don't have to worry about the thread configuration</span>
00018 <span class="comment">   flags.  */</span>
<a name="l00019"></a><a class="code" href="classThread__Pool.html#Thread__Poola1">00019</a> <span class="keywordtype">int</span> <a class="code" href="classThread__Pool.html#Thread__Poola1">Thread_Pool::start</a> (<span class="keywordtype">int</span> pool_size)
00020 {
00021   <span class="keywordflow">return</span> this-&gt;activate (THR_NEW_LWP|THR_DETACHED, pool_size);
00022 }
00023 
00024 <span class="comment">/* Closing the thread pool can be a tricky exercise.  I've decided to</span>
00025 <span class="comment">   take an easy approach and simply enqueue a secret message for each</span>
00026 <span class="comment">   thread we have active.  */</span>
<a name="l00027"></a><a class="code" href="classThread__Pool.html#Thread__Poola2">00027</a> <span class="keywordtype">int</span> <a class="code" href="classThread__Pool.html#Thread__Poola2">Thread_Pool::stop</a> (<span class="keywordtype">void</span>) {
00028   <span class="comment">/* Find out how many threads are currently active */</span>
00029   <span class="keywordtype">int</span> counter = <a class="code" href="classThread__Pool.html#Thread__Pooln0">active_threads_</a>.value ();
00030 
00031   <span class="comment">/* For each one of the active threads, enqueue a "null" event</span>
00032 <span class="comment">    handler.  Below, we'll teach our svc() method that "null" means</span>
00033 <span class="comment">    "shutdown".  */</span>
00034   <span class="keywordflow">while</span> (counter--)
00035     this-&gt;<a class="code" href="classThread__Pool.html#Thread__Poola3">enqueue</a> (0);
00036 
00037   <span class="comment">/* As each svc() method exits, it will decrement the active thread</span>
00038 <span class="comment">    counter.  We just wait here for it to reach zero.  Since we don't</span>
00039 <span class="comment">    know how long it will take, we sleep for a quarter of a second</span>
00040 <span class="comment">    between tries.  */</span>
00041   <span class="keywordflow">while</span> (<a class="code" href="classThread__Pool.html#Thread__Pooln0">active_threads_</a>.value ())
00042     ACE_OS::sleep (ACE_Time_Value (0, 250000));
00043 
00044   <span class="keywordflow">return</span>(0);
00045 }
00046 
00047 <span class="comment">/* When an object wants to do work in the pool, it should call the</span>
00048 <span class="comment">   enqueue() method.  We introduce the ACE_Message_Block here but,</span>
00049 <span class="comment">   unfortunately, we seriously misuse it.  */</span>
<a name="l00050"></a><a class="code" href="classThread__Pool.html#Thread__Poola3">00050</a> <span class="keywordtype">int</span> <a class="code" href="classThread__Pool.html#Thread__Poola3">Thread_Pool::enqueue</a> (ACE_Event_Handler *handler) {
00051   
00052   <span class="comment">/* An ACE_Message_Block is a chunk of data.  You put them into an</span>
00053 <span class="comment">    ACE_Message_Queue.  ACE_Task&lt;&gt; has an ACE_Message_Queue built in.</span>
00054 <span class="comment">    In fact, the parameter to ACE_Task&lt;&gt; is passed directly to</span>
00055 <span class="comment">    ACE_Message_Queue.  If you look back at our header file you'll see</span>
00056 <span class="comment">    that we used ACE_MT_SYNCH as the parameter indicating that we want</span>
00057 <span class="comment">    MultiThread Synch safety.  This allows us to safely put</span>
00058 <span class="comment">    ACE_Message_Block objects into the message queue in one thread and</span>
00059 <span class="comment">    take them out in another.  */</span>
00060 
00061   <span class="comment">/* An ACE_Message_Block wants to have char* data.  We don't have</span>
00062 <span class="comment">    that.  We could cast our ACE_Event_Handler* directly to a char*</span>
00063 <span class="comment">    but I wanted to be more explicit.  Since casting pointers around</span>
00064 <span class="comment">    is a dangerous thing, I've gone out of my way here to be very</span>
00065 <span class="comment">    clear about what we're doing.</span>
00066 <span class="comment"></span>
00067 <span class="comment">    First: Cast the handler pointer to a void pointer.  You can't do</span>
00068 <span class="comment">    any useful work on a void pointer, so this is a clear message that</span>
00069 <span class="comment">    we're making the pointer unusable.</span>
00070 <span class="comment"></span>
00071 <span class="comment">    Next: Cast the void pointer to a char pointer that the ACE_Message_Block will accept.  */</span>
00072   <span class="keywordtype">void</span> *v_data = (<span class="keywordtype">void</span> *) handler;
00073   <span class="keywordtype">char</span> *c_data = (<span class="keywordtype">char</span> *) v_data;
00074 
00075   ACE_Message_Block *mb;
00076 
00077   <span class="comment">/* Construct a new ACE_Message_Block.  For efficiency, you might</span>
00078 <span class="comment">    want to preallocate a stack of these and reuse them.  For</span>
00079 <span class="comment">    simplicity, I'll just create what I need as I need it.  */</span>
00080   ACE_NEW_RETURN (mb,
00081                   ACE_Message_Block (c_data),
00082                   -1);
00083 
00084   <span class="comment">/* Our putq() method is a wrapper around one of the enqueue methods</span>
00085 <span class="comment">    of the ACE_Message_Queue that we own.  Like all good methods, it</span>
00086 <span class="comment">    returns -1 if it fails for some reason.  */</span>
00087   <span class="keywordflow">if</span> (this-&gt;putq (mb) == -1)
00088     {
00089       <span class="comment">/* Another trait of the ACE_Message_Block objects is that they</span>
00090 <span class="comment">        are reference counted.  Since they're designed to be passed</span>
00091 <span class="comment">        around between various objects in several threads we can't</span>
00092 <span class="comment">        just delete them whenever we feel like it.  The release()</span>
00093 <span class="comment">        method is similar to the destroy() method we've used</span>
00094 <span class="comment">        elsewhere.  It watches the reference count and will delete the</span>
00095 <span class="comment">        object when possible.  */</span>
00096       mb-&gt;release ();
00097       <span class="keywordflow">return</span> -1;
00098     }
00099 
00100   <span class="keywordflow">return</span> 0;
00101 }
00102 
00103 <span class="comment">/* The "guard" concept is very powerful and used throughout</span>
00104 <span class="comment">   multi-threaded applications.  A guard normally does some operation</span>
00105 <span class="comment">   on an object at construction and the "opposite" operation at</span>
00106 <span class="comment">   destruction.  For instance, when you guard a mutex (lock) object,</span>
00107 <span class="comment">   the guard will acquire the lock on construction and release it on</span>
00108 <span class="comment">   destruction.  In this way, your method can simply let the guard go</span>
00109 <span class="comment">   out of scope and know that the lock is released.</span>
00110 <span class="comment"></span>
00111 <span class="comment">   Guards aren't only useful for locks however.  In this application</span>
00112 <span class="comment">   I've created two guard objects for quite a different purpose.  */</span>
00113 
00114 <span class="comment">/* The Counter_Guard is constructed with a reference to the thread</span>
00115 <span class="comment">   pool's active thread counter.  The guard increments the counter</span>
00116 <span class="comment">   when it is created and decrements it at destruction.  By creating</span>
00117 <span class="comment">   one of these in svc(), I know that the counter will be decremented</span>
00118 <span class="comment">   no matter how or where svc() returns.  */</span>
<a name="l00119"></a><a class="code" href="classCounter__Guard.html">00119</a> <span class="keyword">class </span><a class="code" href="classCounter__Guard.html">Counter_Guard</a>
00120 {
00121 <span class="keyword">public</span>:
<a name="l00122"></a><a class="code" href="classCounter__Guard.html#Counter__Guarda0">00122</a>   <a class="code" href="classCounter__Guard.html#Counter__Guarda0">Counter_Guard</a> (<a class="code" href="classThread__Pool.html#Thread__Pools1">Thread_Pool::counter_t</a> &amp;counter)
00123     : <a class="code" href="classCounter__Guard.html#Counter__Guardn0">counter_</a> (counter)
00124   {
00125     ++<a class="code" href="classCounter__Guard.html#Counter__Guardn0">counter_</a>;
00126   }
00127 
<a name="l00128"></a><a class="code" href="classCounter__Guard.html#Counter__Guarda1">00128</a>   <a class="code" href="classCounter__Guard.html#Counter__Guarda1">~Counter_Guard</a> (<span class="keywordtype">void</span>)
00129   {
00130     --<a class="code" href="classCounter__Guard.html#Counter__Guardn0">counter_</a>;
00131   }
00132 
00133 <span class="keyword">protected</span>:
<a name="l00134"></a><a class="code" href="classCounter__Guard.html#Counter__Guardn0">00134</a>   <a class="code" href="classThread__Pool.html#Thread__Pools1">Thread_Pool::counter_t</a> &amp;<a class="code" href="classCounter__Guard.html#Counter__Guardn0">counter_</a>;
00135 };
00136 
00137 <span class="comment">/* My Message_Block_Guard is also a little non-traditional.  It</span>
00138 <span class="comment">   doesn't do anything in the constructor but it's destructor ensures</span>
00139 <span class="comment">   that the message block's release() method is called.  This is a</span>
00140 <span class="comment">   cheap way to prevent a memory leak if I need an additional exit</span>
00141 <span class="comment">   point in svc().  */</span>
<a name="l00142"></a><a class="code" href="classMessage__Block__Guard.html">00142</a> <span class="keyword">class </span><a class="code" href="classMessage__Block__Guard.html">Message_Block_Guard</a>
00143 {
00144 <span class="keyword">public</span>:
<a name="l00145"></a><a class="code" href="classMessage__Block__Guard.html#Message__Block__Guarda0">00145</a>   <a class="code" href="classMessage__Block__Guard.html#Message__Block__Guarda0">Message_Block_Guard</a> (ACE_Message_Block *&amp;mb)
00146     : <a class="code" href="classMessage__Block__Guard.html#Message__Block__Guardn0">mb_</a> (mb)
00147   {
00148   }
00149 
<a name="l00150"></a><a class="code" href="classMessage__Block__Guard.html#Message__Block__Guarda1">00150</a>   <a class="code" href="classMessage__Block__Guard.html#Message__Block__Guarda1">~Message_Block_Guard</a> (<span class="keywordtype">void</span>)
00151   {
00152     <a class="code" href="classMessage__Block__Guard.html#Message__Block__Guardn0">mb_</a>-&gt;release ();
00153   }
00154 
00155 <span class="keyword">protected</span>:
<a name="l00156"></a><a class="code" href="classMessage__Block__Guard.html#Message__Block__Guardn0">00156</a>   ACE_Message_Block *&amp;<a class="code" href="classMessage__Block__Guard.html#Message__Block__Guardn0">mb_</a>;
00157 };
00158 
00159 <span class="comment">/* Now we come to the svc() method.  As I said, this is being executed</span>
00160 <span class="comment">   in each thread of the Thread_Pool.  Here, we pull messages off of</span>
00161 <span class="comment">   our built-in ACE_Message_Queue and cause them to do work.  */</span>
<a name="l00162"></a><a class="code" href="classThread__Pool.html#Thread__Poolb0">00162</a> <span class="keywordtype">int</span> <a class="code" href="classThread__Pool.html#Thread__Poolb0">Thread_Pool::svc</a> (<span class="keywordtype">void</span>) {
00163   <span class="comment">/* The getq() method takes a reference to a pointer.  So... we need</span>
00164 <span class="comment">    a pointer to give it a reference to.  */</span>
00165   ACE_Message_Block *mb;
00166 
00167   <span class="comment">/* Create the guard for our active thread counter object.  No matter</span>
00168 <span class="comment">    where we choose to return() from svc(), we now know that the</span>
00169 <span class="comment">    counter will be decremented.  */</span>
00170   <a class="code" href="classCounter__Guard.html">Counter_Guard</a> counter_guard (<a class="code" href="classThread__Pool.html#Thread__Pooln0">active_threads_</a>);
00171 
00172   <span class="comment">/* Get messages from the queue until we have a failure.  There's no</span>
00173 <span class="comment">    real good reason for failure so if it happens, we leave</span>
00174 <span class="comment">    immediately.  */</span>
00175   <span class="keywordflow">while</span> (this-&gt;getq (mb) != -1)
00176     {
00177       <span class="comment">/* A successful getq() will cause "mb" to point to a valid</span>
00178 <span class="comment">        refernce-counted ACE_Message_Block.  We use our guard object</span>
00179 <span class="comment">        here so that we're sure to call the release() method of that</span>
00180 <span class="comment">        message block and reduce it's reference count.  Once the count</span>
00181 <span class="comment">        reaches zero, it will be deleted.  */</span>
00182       <a class="code" href="classMessage__Block__Guard.html">Message_Block_Guard</a> message_block_guard (mb);
00183 
00184       <span class="comment">/* As noted before, the ACE_Message_Block stores it's data as a</span>
00185 <span class="comment">        char*.  We pull that out here and later turn it into an</span>
00186 <span class="comment">        ACE_Event_Handler* */</span>
00187       <span class="keywordtype">char</span> *c_data = mb-&gt;base ();
00188 
00189       <span class="comment">/* We've chosen to use a "null" value as an indication to leave.</span>
00190 <span class="comment">        If the data we got from the queue is not null then we have</span>
00191 <span class="comment">        some work to do.  */</span>
00192       <span class="keywordflow">if</span> (c_data)
00193         {
00194           <span class="comment">/* Once again, we go to great lengths to emphasize the fact</span>
00195 <span class="comment">            that we're casting pointers around in rather impolite</span>
00196 <span class="comment">            ways.  We could have cast the char* directly to an</span>
00197 <span class="comment">            ACE_Event_Handler* but then folks might think that's an OK</span>
00198 <span class="comment">            thing to do.</span>
00199 <span class="comment"></span>
00200 <span class="comment">            (Note: The correct way to use an ACE_Message_Block is to</span>
00201 <span class="comment">            write data into it.  What I should have done was create a</span>
00202 <span class="comment">            message block big enough to hold an event handler pointer</span>
00203 <span class="comment">            and then written the pointer value into the block.  When</span>
00204 <span class="comment">            we got here, I would have to read that data back into a</span>
00205 <span class="comment">            pointer.  While politically correct, it is also a lot of</span>
00206 <span class="comment">            work.  If you're careful you can get away with casting</span>
00207 <span class="comment">            pointers around.)  */</span>
00208           <span class="keywordtype">void</span> *v_data = (<span class="keywordtype">void</span> *) c_data;
00209 
00210           ACE_Event_Handler *handler = (ACE_Event_Handler *) v_data;
00211 
00212           <span class="comment">/* Now that we finally have an event handler pointer, invoke</span>
00213 <span class="comment">            it's handle_input() method.  Since we don't know it's</span>
00214 <span class="comment">            handle, we just give it a default.  That's OK because we</span>
00215 <span class="comment">            know that we're not using the handle in the method anyway.  */</span>
00216           <span class="keywordflow">if</span> (handler-&gt;handle_input (ACE_INVALID_HANDLE) == -1)
00217             {
00218               <span class="comment">/* Tell the handler that it's time to go home.  The</span>
00219 <span class="comment">                "normal" method for shutting down a handler whose</span>
00220 <span class="comment">                handler failed is to invoke handle_close().  This will</span>
00221 <span class="comment">                take care of cleaning it up for us.  Notice how we use</span>
00222 <span class="comment">                the handler's get_handle() method to populate it's</span>
00223 <span class="comment">                "handle" parameter.  Convenient isn't it?  */</span>
00224               handler-&gt;handle_close (handler-&gt;get_handle (), 0);
00225 
00226               <span class="comment">/* Also notice that we don't exit the svc() method here!</span>
00227 <span class="comment">                The first time I did this, I was exiting.  After a few</span>
00228 <span class="comment">                clients disconnect you have an empty thread pool.</span>
00229 <span class="comment">                Hard to do any more work after that...  */</span>
00230             }
00231         }
00232       <span class="keywordflow">else</span>
00233         <span class="comment">/* If we get here, we were given a message block with "null"</span>
00234 <span class="comment">           data.  That is our signal to leave, so we return(0) to</span>
00235 <span class="comment">           leave gracefully.  */</span>
00236           <span class="keywordflow">return</span> 0;     <span class="comment">// Ok, shutdown request</span>
00237 
00238       <span class="comment">// message_block_guard goes out of scope here and releases the</span>
00239       <span class="comment">// message_block instance.</span>
00240     }
00241 
00242   <span class="keywordflow">return</span> 0;
00243 }
00244 
</pre></div><hr><address style="align: right;"><small>Generated on Tue Aug 26 00:00:07 2003 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
