<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>client_handler.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>client_handler.cpp</h1><a href="client__handler_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">// $Id: client_handler.cpp,v 2.4 2003/08/25 08:32:49 markos Exp $</span>
00002 
00003 <span class="comment">/* Since this is the third time we've seen most of this, I'm going to</span>
00004 <span class="comment">   strip out almost all of the comments that you've already seen.</span>
00005 <span class="comment">   That way, you can concentrate on the new items.  */</span>
00006 
00007 <span class="preprocessor">#include "<a class="code" href="client__acceptor_8h.html">client_acceptor.h</a>"</span>
00008 <span class="preprocessor">#include "<a class="code" href="client__handler_8h.html">client_handler.h</a>"</span>
00009 <span class="preprocessor">#include "<a class="code" href="contest_8h.html">contest.h</a>"</span>
00010 
<a name="l00014"></a><a class="code" href="client__handler_8cpp.html#a0">00014</a> <span class="preprocessor">#define REGISTER_MASK ACE_Event_Handler::READ_MASK</span>
<a name="l00015"></a><a class="code" href="client__handler_8cpp.html#a1">00015</a> <span class="preprocessor"></span><span class="preprocessor">#define REMOVE_MASK (ACE_Event_Handler::READ_MASK | ACE_Event_Handler::DONT_CALL)</span>
00016 <span class="preprocessor"></span>
<a name="l00021"></a><a class="code" href="classClient__Handler.html#Client__Handlera0">00021</a> <a class="code" href="classClient__Handler.html#Client__Handlera0">Client_Handler::Client_Handler</a> (<span class="keywordtype">void</span>)
00022   : client_acceptor_(0),
00023     creator_ (ACE_Thread::self ())
00024 {
00025   <a class="code" href="classClient__Handler.html#Client__Handlern2">data</a> = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[<a class="code" href="classconnectionMsgBlock.html#connectionMsgBlocks3connectionMsgBlocks0">connectionMsgBlock::DATASIZE</a>];
00026   <a class="code" href="classClient__Handler.html#Client__Handlern3">srv_counter</a>=0;
00027 }
00028 
<a name="l00029"></a><a class="code" href="classClient__Handler.html#Client__Handlerb2">00029</a> <a class="code" href="classClient__Handler.html#Client__Handlerb2">Client_Handler::~Client_Handler</a> (<span class="keywordtype">void</span>)
00030 {
00031   <span class="keyword">delete</span> <a class="code" href="classClient__Handler.html#Client__Handlern2">data</a>;
00032   this-&gt;peer().close();
00033 }
00034 
00035 <span class="comment">/* Query our acceptor for the concurrency strategy.  Notice that we</span>
00036 <span class="comment">   don't bother to check that our acceptor pointer is valid.  That is</span>
00037 <span class="comment">   proably a bad idea...  */</span>
00038 <span class="keywordtype">int</span>
<a name="l00039"></a><a class="code" href="classClient__Handler.html#Client__Handlerb5">00039</a> <a class="code" href="classClient__Handler.html#Client__Handlerb5">Client_Handler::concurrency</a>(<span class="keywordtype">void</span>)
00040 {
00041   <span class="keywordflow">return</span> this-&gt;<a class="code" href="classClient__Handler.html#Client__Handlerb3">client_acceptor</a> ()-&gt;<a class="code" href="classClient__Acceptor.html#Client__Acceptora5">concurrency</a> ();
00042 }
00043 
00044 <span class="comment">/* And here we ask the acceptor about the thread pool.  */</span>
00045 <a class="code" href="classThread__Pool.html">Thread_Pool</a> *
<a name="l00046"></a><a class="code" href="classClient__Handler.html#Client__Handlerb6">00046</a> <a class="code" href="classClient__Handler.html#Client__Handlerb6">Client_Handler::thread_pool</a> (<span class="keywordtype">void</span>)
00047 {
00048   <span class="keywordflow">return</span> this-&gt;<a class="code" href="classClient__Handler.html#Client__Handlerb3">client_acceptor</a> ()-&gt;<a class="code" href="classClient__Acceptor.html#Client__Acceptora6">thread_pool</a> ();
00049 }
00050 
00051 <span class="comment">/* Back to our open() method.  This is straight out of Tutorial 6.</span>
00052 <span class="comment">   There's nothing additional here for the thread-pool implementation.  */</span>
00053 <span class="keywordtype">int</span>
<a name="l00054"></a><a class="code" href="classClient__Handler.html#Client__Handlera2">00054</a> <a class="code" href="classClient__Handler.html#Client__Handlera2">Client_Handler::open</a> (<span class="keywordtype">void</span> *acceptor)
00055 {
00056   <a class="code" href="classClient__Handler.html#Client__Handlerb3">client_acceptor</a> ((<a class="code" href="classClient__Acceptor.html">Client_Acceptor</a> *) acceptor);
00057 
00058   <span class="keywordflow">if</span> (<a class="code" href="classClient__Handler.html#Client__Handlerb5">concurrency</a> () == <a class="code" href="classClient__Acceptor.html#Client__Acceptors4Client__Acceptors2">Client_Acceptor::thread_per_connection_</a>)
00059     <span class="keywordflow">return</span> this-&gt;activate (THR_DETACHED);
00060 
00061   this-&gt;reactor(<a class="code" href="classClient__Handler.html#Client__Handlerb3">client_acceptor</a>()-&gt;reactor());
00062 
00063   ACE_INET_Addr addr;
00064 
00065   <span class="keywordflow">if</span> (this-&gt;peer().get_remote_addr(addr) == -1)
00066     <span class="keywordflow">return</span> -1;
00067 
00068   <span class="keywordflow">if</span> (this-&gt;reactor()-&gt;register_handler(<span class="keyword">this</span>,
00069                                           <a class="code" href="client__handler_8cpp.html#a0">REGISTER_MASK</a>) == -1)
00070     ACE_ERROR_RETURN ((LM_ERROR,
00071                        <span class="stringliteral">"(%P|%t) can't register with reactor\n"</span>),
00072                       -1);
00073   <span class="keywordflow">return</span> 0;
00074 }
00075 
00076 <span class="comment">/* The destroy() method will remove us from the reactor (with the</span>
00077 <span class="comment">   DONT_CALL flag set!) and then free our memory.  This allows us to</span>
00078 <span class="comment">   be closed from outside of the reactor context without any danger.  */</span>
00079 <span class="keywordtype">void</span>
<a name="l00080"></a><a class="code" href="classClient__Handler.html#Client__Handlera1">00080</a> <a class="code" href="classClient__Handler.html#Client__Handlera1">Client_Handler::destroy</a> (<span class="keywordtype">void</span>)
00081 {
00082   this-&gt;reactor()-&gt;remove_handler (<span class="keyword">this</span>, <a class="code" href="client__handler_8cpp.html#a1">REMOVE_MASK</a>);
00083   <span class="keyword">delete</span> <span class="keyword">this</span>;
00084 }
00085 
00086 <span class="comment">/* As mentioned in the header, the typical way to close an object in a</span>
00087 <span class="comment">  threaded context is to invoke it's close() method.  */</span>
00088 <span class="keywordtype">int</span>
<a name="l00089"></a><a class="code" href="classClient__Handler.html#Client__Handlera3">00089</a> <a class="code" href="classClient__Handler.html#Client__Handlera3">Client_Handler::close</a> (u_long flags)
00090 {
00091   ACE_UNUSED_ARG(flags);
00092 
00093   <span class="comment">/*</span>
00094 <span class="comment">    We use the destroy() method to clean up after ourselves.</span>
00095 <span class="comment">    That will take care of removing us from the reactor and then</span>
00096 <span class="comment">    freeing our memory.</span>
00097 <span class="comment">    */</span>
00098   this-&gt;<a class="code" href="classClient__Handler.html#Client__Handlera1">destroy</a> ();
00099 
00100   <span class="comment">/* Don't forward the close() to the baseclass!  handle_close() above</span>
00101 <span class="comment">    has already taken care of delete'ing.  Forwarding close() would</span>
00102 <span class="comment">    cause that to happen again and things would get really ugly at</span>
00103 <span class="comment">    that point!  */</span>
00104   <span class="keywordflow">return</span> 0;
00105 }
00106 
00107 <span class="comment">/* We will be called when handle_input() returns -1.  That's our queue</span>
00108 <span class="comment">  to delete ourselves to prevent memory leaks.  */</span>
00109 <span class="keywordtype">int</span>
<a name="l00110"></a><a class="code" href="classClient__Handler.html#Client__Handlera4">00110</a> <a class="code" href="classClient__Handler.html#Client__Handlera4">Client_Handler::handle_close</a> (ACE_HANDLE handle,
00111                               ACE_Reactor_Mask mask)
00112 {
00113   ACE_UNUSED_ARG (handle);
00114   ACE_UNUSED_ARG (mask);
00115 
00116   <span class="keyword">delete</span> <span class="keyword">this</span>;
00117 
00118   <span class="keywordflow">return</span> 0;
00119 }
00120 
00121 <span class="comment">/* In the open() method, we registered with the reactor and requested</span>
00122 <span class="comment">   to be notified when there is data to be read.  When the reactor</span>
00123 <span class="comment">   sees that activity it will invoke this handle_input() method on us.</span>
00124 <span class="comment">   As I mentioned, the _handle parameter isn't useful to us but it</span>
00125 <span class="comment">   narrows the list of methods the reactor has to worry about and the</span>
00126 <span class="comment">   list of possible virtual functions we would have to override.</span>
00127 <span class="comment"></span>
00128 <span class="comment">   You've read that much before...  Now we have to do some extra stuff</span>
00129 <span class="comment">   in case we're using the thread-pool implementation.  If we're</span>
00130 <span class="comment">   called by our creator thread then we must be in the reactor.  In</span>
00131 <span class="comment">   that case, we arrange to be put into the thread pool.  If we're not</span>
00132 <span class="comment">   in the creator thread then we must be in the thread pool and we can</span>
00133 <span class="comment">   do some work.  */</span>
00134 <span class="keywordtype">int</span>
<a name="l00135"></a><a class="code" href="classClient__Handler.html#Client__Handlera5">00135</a> <a class="code" href="classClient__Handler.html#Client__Handlera5">Client_Handler::handle_input</a> (ACE_HANDLE handle)
00136 {
00137   ACE_UNUSED_ARG (handle);
00138 
00139   <span class="comment">/* Check our strategy.  If we're using the thread pool and we're in</span>
00140 <span class="comment">    the creation thread then we know we were called by the reactor.  */</span>
00141   <span class="keywordflow">if</span> (<a class="code" href="classClient__Handler.html#Client__Handlerb5">concurrency</a> () == <a class="code" href="classClient__Acceptor.html#Client__Acceptors4Client__Acceptors3">Client_Acceptor::thread_pool_</a>)
00142     {
00143       <span class="keywordflow">if</span> (ACE_OS::thr_equal (ACE_Thread::self(),
00144                              <a class="code" href="classClient__Handler.html#Client__Handlern5">creator_</a>))
00145     {
00146           <span class="comment">/* Remove ourselves from the reactor and ask to be put into</span>
00147 <span class="comment">            the thread pool's queue of work.  (You should be able to</span>
00148 <span class="comment">            use suspend_handler() but I've had problems with that.)</span>
00149 <span class="comment"></span>
00150 <span class="comment">            By removing ourselves from the reactor, we're guaranteed</span>
00151 <span class="comment">            that we won't be called back until the thread pool picks</span>
00152 <span class="comment">            us up out of the queue.  If we didn't remove ourselves,</span>
00153 <span class="comment">            then the reactor would continue to invoke handle_input()</span>
00154 <span class="comment">            and we don't want that to happen.  */</span>
00155           this-&gt;reactor ()-&gt;remove_handler (<span class="keyword">this</span>, <a class="code" href="client__handler_8cpp.html#a1">REMOVE_MASK</a>);
00156           <span class="keywordflow">return</span> this-&gt;<a class="code" href="classClient__Handler.html#Client__Handlerb6">thread_pool</a> ()-&gt;<a class="code" href="classThread__Pool.html#Thread__Poola3">enqueue</a> (<span class="keyword">this</span>);
00157     }
00158     }
00159 
00160   <span class="comment">/* Any strategy other than thread-per-connection will eventually get</span>
00161 <span class="comment">    here.  If we're in the single-threaded implementation or the</span>
00162 <span class="comment">    thread-pool, we still have to pass this way.  */</span>
00163 
00164   <span class="comment">/* Invoke the process() method to do the work but save it's return</span>
00165 <span class="comment">    value instead of returning it immediately.  */</span>
00166 
00167   <span class="keywordtype">int</span> rval = this-&gt;<a class="code" href="classClient__Handler.html#Client__Handlerb1">process</a> (<a class="code" href="classClient__Handler.html#Client__Handlern2">data</a>, <a class="code" href="classconnectionMsgBlock.html#connectionMsgBlocks3connectionMsgBlocks0">connectionMsgBlock::DATASIZE</a>);
00168 
00169   <span class="comment">/* Now, we look again to see if we're in the thread-pool</span>
00170 <span class="comment">    implementation.  If so then we need to re-register ourselves with</span>
00171 <span class="comment">    the reactor so that we can get more work when it is available.</span>
00172 <span class="comment">    (If suspend_handler() worked then we would use resume_handler()</span>
00173 <span class="comment">    here.)  */</span>
00174   <span class="keywordflow">if</span> (<a class="code" href="classClient__Handler.html#Client__Handlerb5">concurrency</a> () == <a class="code" href="classClient__Acceptor.html#Client__Acceptors4Client__Acceptors3">Client_Acceptor::thread_pool_</a>)
00175     {
00176       <span class="keywordflow">if</span> (rval != -1)
00177         <span class="comment">/* If we don't remember to re-register ourselves, then we</span>
00178 <span class="comment">            won't be able to respond to any future client requests.  */</span>
00179         this-&gt;reactor ()-&gt;register_handler (<span class="keyword">this</span>,
00180                                             <a class="code" href="client__handler_8cpp.html#a0">REGISTER_MASK</a>);
00181     }
00182 
00183   <span class="comment">/* Return the result of process() */</span>
00184   <span class="keywordflow">return</span> rval;
00185 }
00186 
00187 <span class="comment">/* Remember that when we leave our svc() method, the framework will</span>
00188 <span class="comment">   take care of calling our close() method so that we can cleanup</span>
00189 <span class="comment">   after ourselves.  */</span>
00190 <span class="keywordtype">int</span>
<a name="l00191"></a><a class="code" href="classClient__Handler.html#Client__Handlerb0">00191</a> <a class="code" href="classClient__Handler.html#Client__Handlerb0">Client_Handler::svc</a> (<span class="keywordtype">void</span>)
00192 {
00193   <span class="keywordflow">while</span> (1)
00194     <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classClient__Handler.html#Client__Handlerb1">process</a> (<a class="code" href="classClient__Handler.html#Client__Handlern2">data</a>, <a class="code" href="classconnectionMsgBlock.html#connectionMsgBlocks3connectionMsgBlocks0">connectionMsgBlock::DATASIZE</a>) == -1)
00195       <span class="keywordflow">return</span> -1;
00196 
00197   <span class="keywordflow">return</span> 0;
00198 }
00199 
<a name="l00200"></a><a class="code" href="classClient__Handler.html#Client__Handlerb1">00200</a> <span class="keywordtype">int</span> <a class="code" href="classClient__Handler.html#Client__Handlerb1">Client_Handler::process</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf,size_t buf_len)
00201 {
00202   <span class="comment">//variable used to store the response to client</span>
00203   <span class="keywordtype">int</span> return_id;
00204   stringstream debug;
00205   ACE_Future&lt;int&gt; result;
00206 
00207   size_t bytes_read;
00208   <span class="keywordflow">switch</span> ( (bytes_read = this-&gt;peer().recv_n (buf, buf_len)) )
00209     {
00210    <span class="keywordflow">case</span> -1:
00211       ACE_ERROR_RETURN ((LM_ERROR,
00212                          <span class="stringliteral">"bad read\n"</span>,
00213                          <span class="stringliteral">"client"</span>),
00214                         0);
00215     <span class="keywordflow">case</span> 0:
00216       ACE_ERROR_RETURN ((LM_ERROR,
00217                          <span class="stringliteral">"closing daemon (fd = %d)\n"</span>,
00218                          this-&gt;get_handle ()),
00219                         -1);
00220     <span class="keywordflow">default</span>:
00221     <span class="keywordflow">if</span> (bytes_read == buf_len) {
00222       <a class="code" href="classconnectionMsgBlock.html">connectionMsgBlock</a> *cmb = <span class="keyword">new</span> <a class="code" href="classconnectionMsgBlock.html">connectionMsgBlock</a>(buf);
00223 
00224       <span class="keywordflow">if</span> ( <a class="code" href="classClient__Handler.html#Client__Handlern3">srv_counter</a>++ &lt; 10 &amp;&amp; cmb-&gt;<a class="code" href="classconnectionMsgBlock.html#connectionMsgBlocka4">isValid</a>() == <span class="keyword">true</span>) {
00225         result = <a class="code" href="classClient__Handler.html#Client__Handlern1">parentContest</a>-&gt;<a class="code" href="classContest.html#Contestm15">processor</a>-&gt;<a class="code" href="classProcessor.html#Processora5">process</a>(cmb);
00226 <span class="comment">//        cout &lt;&lt; "result.ready() = " &lt;&lt; result.ready() &lt;&lt; endl;</span>
00227         result.get(return_id);
00228         peer().send_n(&amp;return_id, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00229 
00230           <span class="keyword">delete</span> cmb;
00231         <span class="keywordflow">return</span> -1;
00232       } <span class="keywordflow">else</span> {
00233         debug.str(<span class="stringliteral">""</span>);
00234         debug &lt;&lt; <span class="stringliteral">"ERROR CRC:"</span>&lt;&lt;<a class="code" href="classClient__Handler.html#Client__Handlern3">srv_counter</a>&lt;&lt;endl;
00235         <a class="code" href="classClient__Handler.html#Client__Handlern1">parentContest</a>-&gt;<a class="code" href="classContest.html#Contestm14">logger</a>-&gt;<a class="code" href="classLogger.html#Loggera7">logMsg</a>(debug.str());
00236         peer().send_n(&amp;(return_id = <a class="code" href="classClient__Handler.html#Client__Handleru2Client__Handleru1">ID_CRC_ERROR</a>), <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00237         ACE_OS::sleep(1);
00238         <span class="keywordflow">return</span> 0;
00239       }
00240     } <span class="keywordflow">else</span>
00241       <span class="keywordflow">return</span> 0;
00242   }
00243 }
00244 
<a name="l00245"></a><a class="code" href="classClient__Handler.html#Client__Handlera6">00245</a> <span class="keywordtype">void</span> <a class="code" href="classClient__Handler.html#Client__Handlera6">Client_Handler::setContest</a>(<a class="code" href="classContest.html">Contest</a> *mycontest) {
00246     <a class="code" href="classClient__Handler.html#Client__Handlern1">parentContest</a> = mycontest;
00247     <span class="keywordflow">return</span>;
00248 }
00249 
<a name="l00250"></a><a class="code" href="classClient__Handler.html#Client__Handlera7">00250</a> <a class="code" href="classContest.html">Contest</a> *<a class="code" href="classClient__Handler.html#Client__Handlera7">Client_Handler::getContest</a>() {
00251     <span class="keywordflow">return</span> <a class="code" href="classClient__Handler.html#Client__Handlern1">parentContest</a>;
00252 }
00253 
</pre></div><hr><address style="align: right;"><small>Generated on Tue Aug 26 00:00:04 2003 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
